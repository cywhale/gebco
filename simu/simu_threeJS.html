<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Terrain Visualization with Three.js</title>
	<!--script src="https://cdn.jsdelivr.net/npm/d3-delaunay@6.0.4/dist/d3-delaunay.min.js"></script-->
	<script src="https://cdn.jsdelivr.net/npm/earcut@2.2.2/dist/earcut.min.js"></script>
    <script type="importmap">
      {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
    </script>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <h2>3D Terrain Visualization</h2>
    <textarea id="jsonInput" rows="4" cols="50"></textarea><br>
    <button id="fetchPlotButton">Fetch and Plot</button>

    <script type="module">
	    //https://threejs.org/docs/#manual/en/introduction/Installation 
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        var scene, camera, renderer, controls;

        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(1.25, 1.25, 1.25);
            // Ensure the camera is pointing at the center of your geometry

            // Adjust camera settings
            camera.near = 0.1;
            camera.far = 10000;
            camera.updateProjectionMatrix();

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
			// Set a clear color for debugging
			renderer.setClearColor(0xaaaaaa, 1);

			// Set ambient light for debugging
			var ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
			scene.add(ambientLight);
			
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
        }
/*
        function fetchAndPlot() {
            const jsonInput = document.getElementById('jsonInput').value;
		    const jsonsrc = jsonInput.replace(" ", "").replace('\n', '').replace('\r', '')
            const url = `https://api.odb.ntu.edu.tw/gebco?mode=zonly&jsonsrc=${encodeURIComponent(jsonsrc)}`;

            fetch(url)
                .then(response => response.json())
                .then(data => {
                    createTerrain(data);
                    animate();
                })
                .catch(error => console.error('Error:', error));
        }
*/		
        async function fetchAndPlot() {
            const jsonInput = document.getElementById('jsonInput').value;
		    const jsonsrc = jsonInput.replace(" ", "").replace('\n', '').replace('\r', '')
            const url = `https://api.odb.ntu.edu.tw/gebco?mode=zonly&jsonsrc=${encodeURIComponent(jsonsrc)}`;

            try{
                const res = await fetch(url)
                if (!res.ok) {
                    console.log("Fail to fetch this URL")
                } else {
                    const data = await res.json()
                    await createTerrain(data);                    
                }
            } catch (err) {
                console.log(err)
            }
        }
/*
function createGeometry(data) {
  const vertices = [];
  const faces = [];
  const lonValues = [...new Set(data.longitude)]; // unique longitudes
  const latValues = [...new Set(data.latitude)];  // unique latitudes

  // Assuming that data is sorted first by latitude, then by longitude
  for (let i = 0; i < latValues.length; i++) {
    for (let j = 0; j < lonValues.length; j++) {
      const index = i * lonValues.length + j;
      if (data.longitude[index] === undefined || data.latitude[index] === undefined) continue;
      vertices.push(new THREE.Vector3(data.longitude[index], data.latitude[index], data.z[index]));

      // Create two triangles for each quad in the grid
      if (i < latValues.length - 1 && j < lonValues.length - 1) {
        const a = index;
        const b = index + lonValues.length;
        const c = index + 1;
        const d = index + lonValues.length + 1;

        // Triangle 1: a, b, c
        // faces.push(new THREE.Face3(a, b, c));

        // Triangle 2: b, d, c
        // faces.push(new THREE.Face3(b, d, c));
		faces.push(a, b, c); // First triangle
        faces.push(b, d, c); // Second triangle
      }
    }
  }

  const geometry = new THREE.BufferGeometry();
  const verticesAttribute = new THREE.BufferAttribute(new Float32Array(vertices), 3);
  geometry.setAttribute('position', verticesAttribute);
  geometry.setIndex(faces);
  
  // Automatically compute normals
  geometry.computeVertexNormals();

  return geometry;
}
*/
function createGeometry(data) {
  // Flatten the input data for earcut
  const vertices = [];
  for (let i = 0; i < data.longitude.length; i++) {
    vertices.push(data.longitude[i], data.latitude[i]);
  }

  // Triangulate the points within the polygon using earcut
  const triangles = earcut(vertices);
  console.log("Triangles: ", triangles)
  // Create vertices for BufferGeometry
  const positions = [];
  for (let i = 0; i < data.longitude.length; i++) {
    positions.push(data.longitude[i], data.latitude[i], data.z[i]);
  }

  // Create BufferGeometry
  const geometry = new THREE.BufferGeometry();
  const verticesAttribute = new THREE.BufferAttribute(new Float32Array(positions), 3);
  geometry.setAttribute('position', verticesAttribute);
  geometry.setIndex(triangles);

  // Automatically compute normals
  geometry.computeVertexNormals();

  return geometry;
}

		
        function createTerrain(data) {
            /*const delaunay = d3.Delaunay.from(
                data.longitude.map((lon, i) => [lon, data.latitude[i]])
            );
            const vertices = [];
            for (let i = 0; i < delaunay.points.length; i += 2) {
                vertices.push(
                    delaunay.points[i], // x
                    delaunay.points[i + 1], // y
                    data.z[i / 2] // z
                );
            }*/
//Take a look: https://github.com/turban/webgl-terrain/tree/master/wireframe
// https://github.com/turban/webgl-terrain/blob/master/wireframe/besseggen.html
// https://htmlpreview.github.io/?https://github.com/turban/webgl-terrain/blob/master/wireframe/besseggen.html	
// blog: https://blog.mastermaps.com/2013/10/terrain-building-with-threejs.html
		
			/* https://stackoverflow.com/questions/74358515/how-to-draw-polygon-in-three-js-using-vertices
			let polyShape = new THREE.Shape(data.longitude.map((lon, i) => new THREE.Vector2(lon, data.latitude[i])))
            const polyGeometry = new THREE.ShapeGeometry(polyShape);
            polyGeometry.setAttribute("position", new THREE.Float32BufferAttribute(data.longitude.map((lon, i) => [lon, data.latitude[i], data.z[i]]).flat(), 3))
            let polygon = new THREE.Mesh(polyGeometry, new THREE.MeshBasicMaterial({ color: 0x0000ff, wireframe: true })) //({ color: "ColorYouWant, side: THREE.DoubleSide}))
            scene.add(polygon);
			camera.lookAt(polygon.position); */
            //console.log("Debug vertices: ", vertices, delaunay.triangles)
            /*const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setIndex(Array.from(delaunay.triangles));

            geometry.computeVertexNormals();
			//console.log("Debug geometry: ", geometry)

            var material = new THREE.MeshBasicMaterial({ color: 0x0000ff, wireframe: true });
            var mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);*/
    const geometry = createGeometry(data);
    const material = new THREE.MeshBasicMaterial({ color: 0x0000ff, wireframe: true });
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    // Adjust camera to look at the center of the mesh
    //const center = new THREE.Vector3();
    //geometry.computeBoundingBox();
    //geometry.boundingBox.getCenter(center);
	//console.log("Center: ", center)
    //camera.lookAt(center);
			animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            controls.update();
        }

        initThreeJS();
		document.getElementById('fetchPlotButton').addEventListener('click', fetchAndPlot);
    </script>
</body>
</html>
